<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>–¢–µ—Ç—Ä–∏—Å - –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –∏–≥—Ä–∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0e27;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 0, 255, 0.03) 2px, rgba(255, 0, 255, 0.03) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(0, 255, 255, 0.03) 2px, rgba(0, 255, 255, 0.03) 4px);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #00ff00;
            overflow-x: hidden;
        }

        .game-container {
            background: #1a1a2e;
            border: 4px solid #ff00ff;
            box-shadow: 
                0 0 20px #ff00ff,
                inset 0 0 20px rgba(255, 0, 255, 0.1);
            padding: 30px;
            max-width: 95vw;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 48px;
            color: #00ffff;
            text-shadow: 
                0 0 10px #00ffff,
                0 0 20px #00ffff,
                0 0 30px #ff00ff,
                3px 3px 0px #ff00ff;
            margin-bottom: 10px;
            letter-spacing: 5px;
        }

        .game-wrapper {
            display: flex;
            gap: 30px;
            justify-content: center;
        }

        #tetris {
            border: 4px solid #00ffff;
            background: #000;
            box-shadow: 
                0 0 20px #00ffff,
                inset 0 0 10px rgba(0, 255, 255, 0.1);
            image-rendering: pixelated;
            touch-action: none;
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .info-box {
            background: #16213e;
            border: 3px solid #00ff00;
            box-shadow: 0 0 10px #00ff00;
            padding: 15px;
            min-width: 220px;
        }

        .info-box h2 {
            font-size: 20px;
            margin-bottom: 10px;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            letter-spacing: 2px;
        }

        .score-display {
            font-size: 36px;
            font-weight: bold;
            color: #00ff00;
            text-align: center;
            text-shadow: 0 0 10px #00ff00;
            font-family: 'Courier New', monospace;
        }

        .next-piece {
            width: 120px;
            height: 120px;
            margin: 0 auto;
            background: #000;
            border: 2px solid #00ffff;
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.2);
        }

        .controls {
            font-size: 14px;
            line-height: 2;
            color: #00ff00;
        }

        .controls p {
            margin: 5px 0;
            text-shadow: 0 0 5px #00ff00;
        }

        .btn {
            background: #16213e;
            color: #00ffff;
            border: 3px solid #00ffff;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px #00ffff;
            box-shadow: 0 0 10px #00ffff;
        }

        .btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px #00ffff;
            text-shadow: none;
        }

        .btn:active {
            transform: scale(0.95);
        }

        #gameOver {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a2e;
            padding: 40px;
            text-align: center;
            border: 4px solid #ff00ff;
            box-shadow: 0 0 30px #ff00ff;
            z-index: 1000;
            max-width: 90vw;
        }

        #gameOver h2 {
            font-size: 48px;
            color: #ff00ff;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff00ff;
        }

        #gameOver p {
            font-size: 24px;
            margin-bottom: 30px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }

        .audio-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #16213e;
            border: 3px solid #00ff00;
            padding: 12px;
            box-shadow: 0 0 15px #00ff00;
            z-index: 200;
            transition: all 0.3s ease;
            max-width: 90vw;
        }

        .audio-controls.minimized {
            padding: 8px;
        }

        .audio-controls.minimized .audio-content {
            display: none;
        }

        .audio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .audio-controls.minimized .audio-header {
            margin-bottom: 0;
        }

        .audio-controls h3 {
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            font-size: 16px;
            margin: 0;
        }

        .minimize-btn {
            background: #1a1a2e;
            border: 2px solid #ff00ff;
            color: #ff00ff;
            padding: 4px 12px;
            cursor: pointer;
            font-size: 16px;
            text-align: center;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .minimize-btn:active {
            background: #ff00ff;
            color: #000;
        }

        .audio-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .music-toggle {
            background: #1a1a2e;
            border: 2px solid #00ffff;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
            box-shadow: 0 0 10px #00ffff;
            font-family: 'Courier New', monospace;
        }

        .music-toggle:active {
            background: #00ffff;
            color: #000;
            text-shadow: none;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .volume-control label {
            color: #00ff00;
            font-size: 14px;
            text-shadow: 0 0 5px #00ff00;
        }

        .volume-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #000;
            outline: none;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #ff00ff;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px #ff00ff;
        }

        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #ff00ff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
            box-shadow: 0 0 10px #ff00ff;
        }

        .volume-value {
            color: #00ffff;
            font-weight: bold;
            min-width: 40px;
            text-align: right;
            text-shadow: 0 0 5px #00ffff;
            font-size: 14px;
        }

        /* –ú–æ–±–∏–ª—å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            gap: 8px;
            z-index: 100;
            flex-direction: column;
            align-items: center;
        }

        .mobile-btn-row {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .mobile-btn {
            width: 65px;
            height: 65px;
            background: rgba(22, 33, 62, 0.95);
            border: 3px solid #00ffff;
            color: #00ffff;
            font-size: 26px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            backdrop-filter: blur(5px);
            transition: all 0.1s;
        }

        .mobile-btn:active {
            background: rgba(0, 255, 255, 0.8);
            color: #000;
            transform: scale(0.92);
            box-shadow: 0 0 25px #00ffff;
        }

        .mobile-btn.wide {
            width: 146px;
            font-size: 16px;
        }

        /* –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ */
        @media (max-width: 768px) {
            body {
                padding: 5px;
                align-items: flex-start;
                padding-top: 80px;
                padding-bottom: 200px;
            }

            .game-container {
                padding: 10px;
                width: 100%;
                border-width: 3px;
            }

            h1 {
                font-size: 28px;
                letter-spacing: 2px;
                margin-bottom: 10px;
            }

            .game-wrapper {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }

            #tetris {
                width: min(90vw, 300px) !important;
                height: min(180vw, 600px) !important;
                border-width: 3px;
            }

            .side-panel {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                width: 100%;
                gap: 10px;
            }

            .info-box {
                min-width: calc(50% - 10px);
                padding: 10px;
                border-width: 2px;
            }

            .info-box h2 {
                font-size: 14px;
                margin-bottom: 5px;
            }

            .score-display {
                font-size: 22px;
            }

            .next-piece {
                width: 80px;
                height: 80px;
            }

            .controls {
                display: none;
            }

            .audio-controls {
                top: 5px;
                right: 5px;
                left: 5px;
                padding: 8px;
                border-width: 2px;
            }

            .audio-header h3 {
                font-size: 14px;
            }

            .minimize-btn {
                font-size: 14px;
                padding: 4px 10px;
            }

            .music-toggle {
                padding: 8px 15px;
                font-size: 16px;
            }

            .volume-control label {
                font-size: 16px;
            }

            .volume-value {
                font-size: 13px;
                min-width: 35px;
            }

            .mobile-controls {
                display: flex;
            }

            #gameOver {
                width: 90%;
                padding: 25px 15px;
                border-width: 3px;
            }

            #gameOver h2 {
                font-size: 32px;
            }

            #gameOver p {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .btn {
                font-size: 16px;
                padding: 12px 20px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding-top: 70px;
            }

            h1 {
                font-size: 24px;
            }

            #tetris {
                width: min(85vw, 250px) !important;
                height: min(170vw, 500px) !important;
            }

            .info-box {
                min-width: calc(50% - 8px);
                padding: 8px;
            }

            .score-display {
                font-size: 20px;
            }

            .next-piece {
                width: 70px;
                height: 70px;
            }

            .mobile-btn {
                width: 60px;
                height: 60px;
                font-size: 24px;
                border-width: 2px;
            }

            .mobile-btn.wide {
                width: 128px;
                font-size: 15px;
            }

            .mobile-btn-row {
                gap: 7px;
            }

            .mobile-controls {
                gap: 7px;
                bottom: 5px;
            }
        }

        @media (max-width: 380px) {
            .mobile-btn {
                width: 55px;
                height: 55px;
                font-size: 22px;
            }

            .mobile-btn.wide {
                width: 117px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="audio-controls" id="audioControls">
        <div class="audio-header">
            <h3>üéµ –ê–£–î–ò–û</h3>
            <button class="minimize-btn" id="minimizeBtn" onclick="toggleMinimize()">‚àí</button>
        </div>
        <div class="audio-content" id="audioContent">
            <button class="music-toggle" id="musicToggle" onclick="toggleMusic()">
                ‚ñ∂Ô∏è –ú–£–ó–´–ö–ê
            </button>
            <div class="volume-control">
                <label>üîä</label>
                <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="30">
                <span class="volume-value" id="volumeValue">30%</span>
            </div>
        </div>
    </div>
    
    <div class="game-container">
        <div class="game-header">
            <h1>‚ö° TETRIS ‚ö°</h1>
        </div>
        
        <div class="game-wrapper">
            <canvas id="tetris" width="300" height="600"></canvas>
            
            <div class="side-panel">
                <div class="info-box">
                    <h2>‚ñ∫ –°–ß–Å–¢</h2>
                    <div class="score-display" id="score">0</div>
                </div>
                
                <div class="info-box">
                    <h2>‚ñ∫ –£–†–û–í–ï–ù–¨</h2>
                    <div class="score-display" id="level" style="font-size: 28px;">1</div>
                </div>
                
                <div class="info-box">
                    <h2>‚ñ∫ –°–õ–ï–î–£–Æ–©–ê–Ø</h2>
                    <canvas class="next-piece" id="nextPiece" width="120" height="120"></canvas>
                </div>
                
                <div class="info-box controls">
                    <h2>‚ñ∫ –£–ü–†–ê–í–õ–ï–ù–ò–ï</h2>
                    <p>‚¨ÖÔ∏è ‚û°Ô∏è / A D - –î–≤–∏–∂–µ–Ω–∏–µ</p>
                    <p>‚¨ÜÔ∏è / W - –ü–æ–≤–æ—Ä–æ—Ç ‚ü≥</p>
                    <p>Z - –ü–æ–≤–æ—Ä–æ—Ç ‚ü≤</p>
                    <p>‚¨áÔ∏è / S - –£—Å–∫–æ—Ä–µ–Ω–∏–µ</p>
                    <p>SPACE - –ü–∞—É–∑–∞</p>
                    <button class="btn" onclick="startGame()">–ù–û–í–ê–Ø –ò–ì–†–ê</button>
                </div>
            </div>
        </div>
    </div>

    <div id="gameOver">
        <h2>GAME OVER!</h2>
        <p>–í–ê–® –°–ß–Å–¢: <span id="finalScore">0</span></p>
        <button class="btn" onclick="restartGame()">–ò–ì–†–ê–¢–¨ –ï–©–Å</button>
    </div>

    <!-- –ú–æ–±–∏–ª—å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
    <div class="mobile-controls" id="mobileControls">
        <div class="mobile-btn-row">
            <div class="mobile-btn" id="btnRotateLeft">‚ü≤</div>
            <div class="mobile-btn" id="btnRotate">‚ü≥</div>
        </div>
        <div class="mobile-btn-row">
            <div class="mobile-btn" id="btnLeft">‚¨Ö</div>
            <div class="mobile-btn" id="btnDown">‚¨á</div>
            <div class="mobile-btn" id="btnRight">‚û°</div>
        </div>
        <div class="mobile-btn-row">
            <div class="mobile-btn wide" id="btnPause">‚è∏ –ü–ê–£–ó–ê</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextPiece');
        const nextCtx = nextCanvas.getContext('2d');
        
        let ROWS = 20;
        let COLS = 10;
        let BLOCK_SIZE = 30;
        
        function toggleMinimize() {
            const audioControls = document.getElementById('audioControls');
            const minimizeBtn = document.getElementById('minimizeBtn');
            audioControls.classList.toggle('minimized');
            minimizeBtn.textContent = audioControls.classList.contains('minimized') ? '+' : '‚àí';
        }
        
        function adjustCanvasSize() {
            const vw = window.innerWidth;
            if (vw <= 380) {
                canvas.width = Math.min(vw * 0.85, 250);
                canvas.height = canvas.width * 2;
                BLOCK_SIZE = canvas.width / 10;
            } else if (vw <= 480) {
                canvas.width = Math.min(vw * 0.85, 250);
                canvas.height = canvas.width * 2;
                BLOCK_SIZE = canvas.width / 10;
            } else if (vw <= 768) {
                canvas.width = Math.min(vw * 0.9, 300);
                canvas.height = canvas.width * 2;
                BLOCK_SIZE = canvas.width / 10;
            } else {
                canvas.width = 300;
                canvas.height = 600;
                BLOCK_SIZE = 30;
            }
            ROWS = 20;
            COLS = 10;
            
            const scale = BLOCK_SIZE / 30;
            nextCanvas.width = 120 * scale;
            nextCanvas.height = 120 * scale;
        }
        
        adjustCanvasSize();
        
        let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        
        const SHAPES = {
            I: [[1, 1, 1, 1]],
            O: [[1, 1], [1, 1]],
            T: [[0, 1, 0], [1, 1, 1]],
            S: [[0, 1, 1], [1, 1, 0]],
            Z: [[1, 1, 0], [0, 1, 1]],
            J: [[1, 0, 0], [1, 1, 1]],
            L: [[0, 0, 1], [1, 1, 1]]
        };
        
        const COLORS = {
            I: '#00ffff',
            O: '#ffff00',
            T: '#ff00ff',
            S: '#00ff00',
            Z: '#ff0000',
            J: '#0080ff',
            L: '#ff8000'
        };
        
        let currentPiece = null;
        let currentX = 0;
        let currentY = 0;
        let nextPiece = null;
        let score = 0;
        let level = 1;
        let gameLoop = null;
        let isPaused = false;
        let gameSpeed = 1000;
        let volume = 0.3;
        
        let animationFrame = null;
        let targetY = 0;
        let displayY = 0;
        let animationSpeed = 0.15;
        
        let audioContext = null;
        let isMusicPlaying = false;
        
        const tetrisMelody = [
            {note: 659.25, duration: 500}, {note: 493.88, duration: 250},
            {note: 523.25, duration: 250}, {note: 587.33, duration: 500},
            {note: 523.25, duration: 250}, {note: 493.88, duration: 250},
            {note: 440.00, duration: 500}, {note: 440.00, duration: 250},
            {note: 523.25, duration: 250}, {note: 659.25, duration: 500},
            {note: 587.33, duration: 250}, {note: 523.25, duration: 250},
            {note: 493.88, duration: 750}, {note: 523.25, duration: 250},
            {note: 587.33, duration: 500}, {note: 659.25, duration: 500},
            {note: 523.25, duration: 500}, {note: 440.00, duration: 500},
            {note: 440.00, duration: 500}, {note: 0, duration: 250},
            {note: 587.33, duration: 500}, {note: 698.46, duration: 250},
            {note: 880.00, duration: 500}, {note: 783.99, duration: 250},
            {note: 698.46, duration: 250}, {note: 659.25, duration: 750},
            {note: 523.25, duration: 250}, {note: 659.25, duration: 500},
            {note: 587.33, duration: 250}, {note: 523.25, duration: 250},
            {note: 493.88, duration: 500}, {note: 493.88, duration: 250},
            {note: 523.25, duration: 250}, {note: 587.33, duration: 500},
            {note: 659.25, duration: 500}, {note: 523.25, duration: 500},
            {note: 440.00, duration: 500}, {note: 440.00, duration: 500},
            {note: 0, duration: 500}
        ];
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function playNote(frequency, duration) {
            if (!audioContext || frequency === 0) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            filter.type = 'lowpass';
            filter.frequency.value = 2000;
            filter.Q.value = 1;
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'triangle';
            oscillator.frequency.value = frequency;
            
            const now = audioContext.currentTime;
            const attackTime = 0.01;
            const releaseTime = 0.1;
            
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume * 0.15, now + attackTime);
            gainNode.gain.setValueAtTime(volume * 0.15, now + duration / 1000 - releaseTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration / 1000);
            
            oscillator.start(now);
            oscillator.stop(now + duration / 1000);
        }
        
        let currentNoteIndex = 0;
        let musicInterval = null;
        
        function playTetrisMusic() {
            if (!isMusicPlaying) return;
            const note = tetrisMelody[currentNoteIndex];
            playNote(note.note, note.duration);
            currentNoteIndex = (currentNoteIndex + 1) % tetrisMelody.length;
            musicInterval = setTimeout(playTetrisMusic, note.duration);
        }
        
        function toggleMusic() {
            initAudio();
            isMusicPlaying = !isMusicPlaying;
            const toggle = document.getElementById('musicToggle');
            toggle.textContent = isMusicPlaying ? '‚è∏Ô∏è –ü–ê–£–ó–ê' : '‚ñ∂Ô∏è –ú–£–ó–´–ö–ê';
            
            if (isMusicPlaying) {
                playTetrisMusic();
            } else {
                clearTimeout(musicInterval);
            }
        }
        
        function createPiece() {
            const shapes = Object.keys(SHAPES);
            const shapeKey = shapes[Math.floor(Math.random() * shapes.length)];
            return {
                shape: SHAPES[shapeKey],
                color: COLORS[shapeKey],
                key: shapeKey
            };
        }
        
        function drawBlock(x, y, color, context = ctx) {
            context.fillStyle = color;
            context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            const gradient = context.createLinearGradient(
                x * BLOCK_SIZE, y * BLOCK_SIZE, 
                (x + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE
            );
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, '#000000');
            context.fillStyle = gradient;
            context.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
            
            context.strokeStyle = '#000';
            context.lineWidth = 2;
            context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            context.shadowColor = color;
            context.shadowBlur = 10;
            context.strokeStyle = color;
            context.lineWidth = 1;
            context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            context.shadowBlur = 0;
        }
        
        function drawBoard() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col]) {
                        drawBlock(col, row, board[row][col]);
                    }
                }
            }
        }
        
        function drawPiece() {
            if (!currentPiece) return;
            displayY += (targetY - displayY) * animationSpeed;
            
            for (let row = 0; row < currentPiece.shape.length; row++) {
                for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col]) {
                        drawBlock(currentX + col, displayY + row, currentPiece.color);
                    }
                }
            }
        }
        
        function drawNextPiece() {
            nextCtx.fillStyle = '#000';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if (!nextPiece) return;
            
            const scale = BLOCK_SIZE / 30;
            const scaledBlockSize = BLOCK_SIZE;
            const offsetX = (4 - nextPiece.shape[0].length) / 2;
            const offsetY = (4 - nextPiece.shape.length) / 2;
            
            for (let row = 0; row < nextPiece.shape.length; row++) {
                for (let col = 0; col < nextPiece.shape[row].length; col++) {
                    if (nextPiece.shape[row][col]) {
                        nextCtx.fillStyle = nextPiece.color;
                        nextCtx.fillRect(
                            (offsetX + col) * scaledBlockSize, 
                            (offsetY + row) * scaledBlockSize, 
                            scaledBlockSize, 
                            scaledBlockSize
                        );
                        nextCtx.strokeStyle = '#000';
                        nextCtx.lineWidth = 2;
                        nextCtx.strokeRect(
                            (offsetX + col) * scaledBlockSize, 
                            (offsetY + row) * scaledBlockSize, 
                            scaledBlockSize, 
                            scaledBlockSize
                        );
                    }
                }
            }
        }
        
        function checkCollision(piece, x, y) {
            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        const newX = x + col;
                        const newY = y + row;
                        
                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return true;
                        }
                        
                        if (newY >= 0 && board[newY][newX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function rotatePiece() {
            const rotated = {
                ...currentPiece,
                shape: currentPiece.shape[0].map((_, i) =>
                    currentPiece.shape.map(row => row[i]).reverse()
                )
            };
            
            if (!checkCollision(rotated, currentX, currentY)) {
                currentPiece = rotated;
            } else {
                for (let offset of [1, -1, 2, -2]) {
                    if (!checkCollision(rotated, currentX + offset, currentY)) {
                        currentX += offset;
                        currentPiece = rotated;
                        break;
                    }
                }
            }
        }
        
        function rotatePieceCounterClockwise() {
            const rotated = {
                ...currentPiece,
                shape: currentPiece.shape[0].map((_, i) =>
                    currentPiece.shape.map(row => row[row.length - 1 - i])
                )
            };
            
            if (!checkCollision(rotated, currentX, currentY)) {
                currentPiece = rotated;
            } else {
                for (let offset of [1, -1, 2, -2]) {
                    if (!checkCollision(rotated, currentX + offset, currentY)) {
                        currentX += offset;
                        currentPiece = rotated;
                        break;
                    }
                }
            }
        }
        
        function move(dir) {
            if (isPaused) return;
            const newX = currentX + dir;
            if (!checkCollision(currentPiece, newX, currentY)) {
                currentX = newX;
            }
        }
        
        function moveDown() {
            if (isPaused) return;
            
            if (!checkCollision(currentPiece, currentX, currentY + 1)) {
                currentY++;
                targetY = currentY;
            } else {
                displayY = targetY = currentY;
                mergePiece();
                clearLines();
                spawnPiece();
            }
        }
        
        function mergePiece() {
            for (let row = 0; row < currentPiece.shape.length; row++) {
                for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col]) {
                        board[currentY + row][currentX + col] = currentPiece.color;
                    }
                }
            }
        }
        
        function clearLines() {
            let linesCleared = 0;
            
            for (let row = ROWS - 1; row >= 0; row--) {
                if (board[row].every(cell => cell !== 0)) {
                    board.splice(row, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    row++;
                }
            }
            
            if (linesCleared > 0) {
                score += linesCleared * 100 * level;
                document.getElementById('score').textContent = score;
                
                level = Math.floor(score / 1000) + 1;
                document.getElementById('level').textContent = level;
                gameSpeed = Math.max(100, 1000 - (level - 1) * 100);
                
                if (audioContext) {
                    playNote(880, 100);
                    setTimeout(() => playNote(1046.5, 150), 100);
                }
            }
        }
        
        function spawnPiece() {
            currentPiece = nextPiece || createPiece();
            nextPiece = createPiece();
            currentX = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
            currentY = 0;
            
            targetY = currentY;
            displayY = currentY;
            
            drawNextPiece();
            
            if (checkCollision(currentPiece, currentX, currentY)) {
                gameOver();
            }
        }
        
        function gameOver() {
            cancelAnimationFrame(animationFrame);
            
            if (isMusicPlaying) {
                isMusicPlaying = false;
                clearTimeout(musicInterval);
                const toggle = document.getElementById('musicToggle');
                toggle.textContent = '‚ñ∂Ô∏è –ú–£–ó–´–ö–ê';
            }
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
            
            if (audioContext) {
                setTimeout(() => {
                    playNote(440, 200);
                    setTimeout(() => playNote(392, 200), 200);
                    setTimeout(() => playNote(349.23, 400), 400);
                }, 100);
            }
        }
        
        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            startGame();
        }
        
        function startGame() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0;
            level = 1;
            gameSpeed = 1000;
            isPaused = false;
            
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            
            clearInterval(gameLoop);
            
            nextPiece = createPiece();
            spawnPiece();
            
            let lastTime = Date.now();
            let dropCounter = 0;
            let dropInterval = gameSpeed;
            
            function gameLoopAnimation() {
                if (!isPaused) {
                    const now = Date.now();
                    const deltaTime = now - lastTime;
                    lastTime = now;
                    
                    dropCounter += deltaTime;
                    if (dropCounter > dropInterval) {
                        moveDown();
                        dropCounter = 0;
                        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                    }
                    
                    draw();
                }
                animationFrame = requestAnimationFrame(gameLoopAnimation);
            }
            
            gameLoopAnimation();
            
            if (!isMusicPlaying) {
                toggleMusic();
            }
        }
        
        function draw() {
            drawBoard();
            drawPiece();
        }
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A' || e.key === '—Ñ' || e.key === '–§') {
                move(-1);
                e.preventDefault();
            } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D' || e.key === '–≤' || e.key === '–í') {
                move(1);
                e.preventDefault();
            } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S' || e.key === '—ã' || e.key === '–´') {
                moveDown();
                e.preventDefault();
            } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W' || e.key === '—Ü' || e.key === '–¶') {
                rotatePiece();
                e.preventDefault();
            } else if (e.key === 'z' || e.key === 'Z' || e.key === '—è' || e.key === '–Ø') {
                rotatePieceCounterClockwise();
                e.preventDefault();
            } else if (e.key === ' ') {
                isPaused = !isPaused;
                e.preventDefault();
            }
        });
        
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');
        
        volumeSlider.addEventListener('input', (e) => {
            volume = e.target.value / 100;
            volumeValue.textContent = e.target.value + '%';
        });
        
        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');
        const btnDown = document.getElementById('btnDown');
        const btnRotate = document.getElementById('btnRotate');
        const btnRotateLeft = document.getElementById('btnRotateLeft');
        const btnPause = document.getElementById('btnPause');
        
        function setupTouchButton(button, action) {
            let touchInterval = null;
            let isTouching = false;
            
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (isTouching) return;
                isTouching = true;
                
                action();
                
                if (button === btnLeft || button === btnRight || button === btnDown) {
                    touchInterval = setInterval(action, 100);
                }
            });
            
            button.addEventListener('touchend', (e) => {
                e.preventDefault();
                isTouching = false;
                if (touchInterval) {
                    clearInterval(touchInterval);
                    touchInterval = null;
                }
            });
            
            button.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                isTouching = false;
                if (touchInterval) {
                    clearInterval(touchInterval);
                    touchInterval = null;
                }
            });
        }
        
        setupTouchButton(btnLeft, () => move(-1));
        setupTouchButton(btnRight, () => move(1));
        setupTouchButton(btnDown, () => moveDown());
        setupTouchButton(btnRotate, () => rotatePiece());
        setupTouchButton(btnRotateLeft, () => rotatePieceCounterClockwise());
        
        btnPause.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isPaused = !isPaused;
            btnPause.textContent = isPaused ? '‚ñ∂ –ò–ì–†–ê–¢–¨' : '‚è∏ –ü–ê–£–ó–ê';
        });
        
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let hasMoved = false;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchStartTime = Date.now();
            hasMoved = false;
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (hasMoved) return;
            
            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            const deltaX = touchX - touchStartX;
            const deltaY = touchY - touchStartY;
            
            if (Math.abs(deltaX) > 20 || Math.abs(deltaY) > 20) {
                hasMoved = true;
                
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (deltaX > 0) {
                        move(1);
                    } else {
                        move(-1);
                    }
                } else {
                    if (deltaY > 0) {
                        moveDown();
                    } else {
                        rotatePiece();
                    }
                }
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            if (!hasMoved && (Date.now() - touchStartTime) < 200) {
                rotatePiece();
            }
        });
        
        window.addEventListener('resize', () => {
            adjustCanvasSize();
            draw();
            drawNextPiece();
        });
        
        window.addEventListener('load', () => {
            startGame();
        });
    </script>
</body>
</html>